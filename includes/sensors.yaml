# ============================================================================
# SENSORS & MEASUREMENTS
# ============================================================================
# Temperature sensor (DS18B20), WiFi signal strength, and sensor diagnostics

sensor:
  # DS18B20 Temperature Sensor
  - platform: dallas_temp
    one_wire_id: ow_bus
    id: gazebo_temp
    name: "Gazebo Temperature"
    address: 0x7ce066bd0164ff28
    resolution: 12
    update_interval: 10s
    filters:
      # Moving average to smooth readings (recalculates when offset changes)
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
      # Apply temperature offset/calibration (recalculates dynamically)
      - lambda: |-
          return x + id(temp_offset).state;
      # Clamp to valid range (-40°C to 85°C)
      - clamp:
          min_value: -40
          max_value: 85
      # Rate limiting: max ±1°C change per reading
      - delta: 1.0

    # Bad read detection and heating control
    on_value:
      then:
        - lambda: |-
            if (isnan(x)) {
              id(bad_read_count) += 1;
              ESP_LOGI("TEMP_SENSOR", "Bad temperature read #%d", id(bad_read_count));
              if (id(bad_read_count) > 10) {
                id(sensor_malfunction).publish_state(true);
                ESP_LOGI("TEMP_SENSOR", "ALARM: Sensor malfunction detected!");
              }
            } else {
              if (id(bad_read_count) > 0) {
                ESP_LOGI("TEMP_SENSOR", "Sensor recovered - resetting bad read counter");
              }
              id(bad_read_count) = 0;
              if (id(sensor_malfunction).state) {
                id(sensor_malfunction).publish_state(false);
              }
            }
        # Force climate platform to republish state with updated temperature
        # This ensures the climate entity's "Currently" temperature updates in Home Assistant
        # AND it triggers the climate platform to re-evaluate if it should heat/idle
        - if:
            condition:
              lambda: |-
                return !isnan(x);
            then:
              - lambda: |-
                  auto* climate = id(propane_stove_thermostat);
                  if (climate != nullptr) {
                    climate->publish_state();
                    ESP_LOGD("CLIMATE_SYNC", "Climate state republished with temperature: %.1f°C", x);
                  }
              # Check if relay should be on/off based on current climate state
              - script.execute: apply_priority_overrides
        # Update Nextion display - Try ALL common component names with page prefix
        - lambda: |-
            if (id(gazebo_nextion).is_failed() == false) {
              ESP_LOGD("NEXTION_DEBUG", "Sending temp %.1f to display (Page 0)", x);
              // Try Number components with page prefix
              id(gazebo_nextion).send_command_printf("page0.temp.val=%d", (int)x);
              id(gazebo_nextion).send_command_printf("page0.n0.val=%d", (int)x);
              id(gazebo_nextion).send_command_printf("page0.n1.val=%d", (int)x);
              // Try Text components with page prefix
              id(gazebo_nextion).send_command_printf("page0.t0.txt=\"%.0f\"", x);
              id(gazebo_nextion).send_command_printf("page0.t1.txt=\"%.0f\"", x);
            }

  # WiFi Signal Strength
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_strength
    update_interval: 60s
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
