# ============================================================================
# SENSORS & MEASUREMENTS
# ============================================================================
# Temperature sensor (DS18B20), WiFi signal strength, and sensor diagnostics

sensor:
  # DS18B20 Temperature Sensor
  - platform: dallas_temp
    one_wire_id: ow_bus
    id: gazebo_temp
    name: "Gazebo Temperature"
    address: 0x7ce066bd0164ff28
    resolution: 12
    update_interval: 10s
    filters:
      # Moving average to smooth readings (recalculates when offset changes)
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1
      # Apply temperature offset/calibration (recalculates dynamically)
      - lambda: |-
          return x + id(temp_offset).state;
      # Clamp to valid range (-40°C to 85°C)
      - clamp:
          min_value: -40
          max_value: 85
      # Rate limiting: max ±1°C change per reading
      - delta: 1.0

    # Bad read detection and heating control
    on_value:
      then:
        - lambda: |-
            if (isnan(x)) {
              id(bad_read_count) += 1;
              ESP_LOGI("TEMP_SENSOR", "Bad temperature read #%d", id(bad_read_count));
              if (id(bad_read_count) > 10) {
                id(sensor_malfunction).publish_state(true);
                ESP_LOGI("TEMP_SENSOR", "ALARM: Sensor malfunction detected!");
              }
            } else {
              if (id(bad_read_count) > 0) {
                ESP_LOGI("TEMP_SENSOR", "Sensor recovered - resetting bad read counter");
              }
              id(bad_read_count) = 0;
              if (id(sensor_malfunction).state) {
                id(sensor_malfunction).publish_state(false);
              }
            }
        # Force climate platform to republish state with updated temperature
        # This ensures the climate entity's "Currently" temperature updates in Home Assistant
        # AND it triggers the climate platform to re-evaluate if it should heat/idle
        - if:
            condition:
              lambda: |-
                return !isnan(x);
            then:
              - lambda: |-
                  auto* climate = id(propane_stove_thermostat);
                  if (climate != nullptr) {
                    climate->publish_state();
                    ESP_LOGD("CLIMATE_SYNC", "Climate state republished with temperature: %.1f°C", x);
                  }
              # This script is no longer needed here, the climate platform will
              # automatically re-evaluate its state when the sensor value changes.
              # - script.execute: manage_heating

  # WiFi Signal Strength
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_strength
    update_interval: 60s
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
