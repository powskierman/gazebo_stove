# ============================================================================
# ENTITIES - User Configuration & Status
# ============================================================================
# Number sliders, select dropdowns, binary sensors, and text sensors

# ============================================================================
# BINARY SENSORS - Status & Alarms
# ============================================================================

binary_sensor:
  # Sensor Malfunction Alarm
  - platform: template
    name: "Sensor Malfunction"
    id: sensor_malfunction
    icon: "mdi:alert-circle"
    device_class: problem
    lambda: |-
      return id(bad_read_count) > 10;

# ============================================================================
# NUMBER ENTITIES - User Configuration
# ============================================================================

number:
  # Desired Temperature Setpoint
  - platform: template
    name: "Desired Temperature"
    id: desired_temp
    min_value: 5
    max_value: 35
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    restore_value: yes
    initial_value: 22
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Desired temperature set to %.1f°C"
            args: ["x"]
        # Update climate platform's target temperature
        - lambda: |-
            auto* climate = id(propane_stove_thermostat);
            if (climate != nullptr) {
              climate->target_temperature = x;
              climate->publish_state();
              ESP_LOGD("TEMP_SYNC", "Climate platform target updated to %.1f°C", x);
            }
        # Update Nextion display if available
        - lambda: |-
            if (id(gazebo_nextion).is_failed() == false) {
              id(gazebo_nextion).send_command_printf("n1.val=%d", (int)x);
            }
        # The climate platform will automatically re-evaluate upon temperature change.
        # - script.execute: manage_heating

  # Temperature Offset (Calibration)
  - platform: template
    name: "Temperature Offset"
    id: temp_offset
    min_value: -5
    max_value: 5
    step: 0.1
    unit_of_measurement: "°C"
    icon: "mdi:plus-minus"
    restore_value: yes
    initial_value: 0
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Temperature offset set to %.1f°C"
            args: ["x"]
        # Update the internal value and publish state
        - lambda: |-
            id(temp_offset).publish_state(x);
            ESP_LOGI("TEMP_OFFSET", "Offset changed to %.1f°C", x);

  # Heating Hysteresis (deadband for stove control)
  - platform: template
    name: "Heating Hysteresis"
    id: heating_hysteresis
    min_value: 1
    max_value: 5
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:fire"
    restore_value: yes
    initial_value: 2
    set_action:
      then:
        - logger.log:
            format: "Heating hysteresis set to %.1f°C"
            args: ["x"]
        # Note: Hysteresis entity is for reference only
        # ESPHome climate platform uses its own internal hysteresis calculation

  # ========================================================================
  # Schedule Time Configuration Entities
  # ========================================================================

  # Home Mode Time (Hour)
  - platform: template
    name: "Home Mode Time (Hour)"
    id: home_mode_hour
    min_value: 0
    max_value: 23
    step: 1
    unit_of_measurement: "h"
    icon: "mdi:home-clock"
    restore_value: yes
    initial_value: 6
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Home mode hour set to: %.0f"
            args: ["x"]

  # Home Mode Time (Minute)
  - platform: template
    name: "Home Mode Time (Minute)"
    id: home_mode_minute
    min_value: 0
    max_value: 59
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:home-clock"
    restore_value: yes
    initial_value: 0
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Home mode minute set to: %.0f"
            args: ["x"]

  # Away Mode Time (Hour)
  - platform: template
    name: "Away Mode Time (Hour)"
    id: away_mode_hour
    min_value: 0
    max_value: 23
    step: 1
    unit_of_measurement: "h"
    icon: "mdi:clock-out"
    restore_value: yes
    initial_value: 22
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Away mode hour set to: %.0f"
            args: ["x"]

  # Away Mode Time (Minute)
  - platform: template
    name: "Away Mode Time (Minute)"
    id: away_mode_minute
    min_value: 0
    max_value: 59
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:clock-out"
    restore_value: yes
    initial_value: 0
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Away mode minute set to: %.0f"
            args: ["x"]

# ============================================================================
# CLIMATE ENTITY - Thermostat Control (Single Source of Truth)
# ============================================================================
# ESPHome climate platform is the single decision maker:
# - Compares desired_temp vs current_temp
# - Implements hysteresis for stable control
# - Calls heat_action when heating is needed
# - Calls idle_action when heating should stop
#
# Priority system (in automation.yaml) wraps around climate:
# - Override heat_action when Manual Stop, Manual Run, or Away Mode is active
# - Climate platform is NOT bypassed, just conditionally overridden
# - This keeps climate as single source of truth while adding application-specific logic

climate:
  - platform: thermostat
    name: "Propane Stove Thermostat"
    id: propane_stove_thermostat
    sensor: gazebo_temp
    # Reduced times to allow faster response when setpoint changes
    min_heating_off_time: 5s
    min_heating_run_time: 30s
    min_idle_time: 5s

    # Heat action: Turn relay ON when thermostat decides to heat
    heat_action:
      - logger.log: "THERMOSTAT: heat_action triggered"
      # Sync desired_temp number entity with climate target temperature
      - lambda: |-
          id(desired_temp).publish_state(id(propane_stove_thermostat).target_temperature);
          ESP_LOGD("TEMP_SYNC", "Synced desired_temp to climate target: %.1f°C",
                   id(propane_stove_thermostat).target_temperature);
      # Directly turn the relay on, then let manage_heating apply any overrides.
      - switch.turn_on: relay
      - script.execute: manage_heating

    # Idle action: Turn relay OFF when thermostat decides to stop heating
    idle_action:
      - logger.log: "THERMOSTAT: idle_action triggered"
      # Sync desired_temp number entity with climate target temperature
      - lambda: |-
          id(desired_temp).publish_state(id(propane_stove_thermostat).target_temperature);
          ESP_LOGD("TEMP_SYNC", "Synced desired_temp to climate target: %.1f°C",
                   id(propane_stove_thermostat).target_temperature);
      # Directly turn the relay off, then let manage_heating apply any overrides.
      - switch.turn_off: relay
      - script.execute: manage_heating

# ============================================================================
# SELECT ENTITIES - Mode Selection
# ============================================================================

select:
  # Presence Mode
  - platform: template
    name: "Presence Mode"
    id: presence_mode
    options:
      - "home"
      - "away"
    lambda: |-
      return id(presence_mode_state);
    set_action:
      then:
        - logger.log:
            format: "Presence mode set to: %s (manual override)"
            args: ["x.c_str()"]
        - lambda: |-
            id(presence_mode_state) = x;
            id(presence_mode_manual) = true;
            id(presence_mode).publish_state(x);
            ESP_LOGI("PRESENCE", "Manual mode set - blocking schedule overrides");
        # Re-evaluate heating state when presence mode changes
        - script.execute: manage_heating

# ============================================================================
# SWITCH ENTITIES - Manual Overrides & Schedule Control
# ============================================================================
# Note: Manual Run, Manual Stop, and Heating Schedule switches are defined
# in hardware.yaml to prevent YAML section conflicts when merging includes

# ============================================================================
# TEXT SENSORS - Status Messages & Information
# ============================================================================

text_sensor:
  # WiFi Information
  - platform: wifi_info
    ip_address:
      name: "Device IP Address"
      id: device_ip
      entity_category: "diagnostic"
    ssid:
      name: "WiFi SSID"
      id: wifi_ssid
      entity_category: "diagnostic"
    mac_address:
      name: "MAC Address"
      entity_category: "diagnostic"
    bssid:
      name: "WiFi BSSID"
      entity_category: "diagnostic"

  # System Status Message
  - platform: template
    name: "System Status"
    id: system_status
    update_interval: 10s
    lambda: |-
      if (id(sensor_malfunction).state) {
        return std::string("ALARM: Sensor Malfunction");
      } else if (!id(gazebo_nextion).is_failed()) {
        return std::string("OK - Nextion Connected");
      } else {
        return std::string("OK - Display Offline");
      }

# ============================================================================
# GLOBAL VARIABLES - Internal State Tracking
# ============================================================================

globals:
  # Bad temperature read counter
  - id: bad_read_count
    type: int
    restore_value: no
    initial_value: '0'

  # Manual run state tracker (used by priority management system)
  - id: manual_run_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # Manual stop state tracker (used by priority management system)
  - id: manual_stop_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # Presence mode state tracker (Home/Away mode storage)
  # This global variable stores the presence mode state for the presence_mode select entity
  # It is used by the template select entity's lambda to read/write the current mode
  - id: presence_mode_state
    type: std::string
    restore_value: yes
    initial_value: '"home"'

  # Flag to track if presence mode was manually set (not by schedule)
  # When true, the schedule automation will not override the mode
  # Reset to false when schedule changes the mode
  - id: presence_mode_manual
    type: bool
    restore_value: no
    initial_value: 'false'
