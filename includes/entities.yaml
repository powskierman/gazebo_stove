# ============================================================================
# ENTITIES - User Configuration & Status
# ============================================================================
# Number sliders, select dropdowns, binary sensors, and text sensors

# ============================================================================
# BINARY SENSORS - Status & Alarms
# ============================================================================

binary_sensor:
  # Sensor Malfunction Alarm
  - platform: template
    name: "Sensor Malfunction"
    id: sensor_malfunction
    icon: "mdi:alert-circle"
    device_class: problem
    lambda: |-
      return id(bad_read_count) > 10;

# ============================================================================
# NUMBER ENTITIES - User Configuration
# ============================================================================

number:
  # Desired Temperature Setpoint
  - platform: template
    name: "Desired Temperature"
    id: desired_temp
    min_value: 5
    max_value: 35
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    restore_value: yes
    initial_value: 22
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Desired temperature set to %.1f°C"
            args: ["x"]
        # Update Nextion display if available
        - lambda: |-
            if (id(gazebo_nextion).is_failed() == false) {
              id(gazebo_nextion).send_command_printf("n1.val=%d", (int)x);
            }
        # Small delay to allow state to sync
        - delay: 50ms
        # Sync ESPHome climate platform target temperature with desired_temp
        # This ensures climate platform uses the same target as the number entity
        # The climate platform receives updates from Home Assistant API, but we also sync here
        # to ensure consistency when desired_temp is changed directly
        - lambda: |-
            // Set the climate platform's target temperature to match desired_temp
            auto* climate = id(propane_stove_thermostat);
            if (climate != nullptr) {
              climate->target_temperature = x;
              climate->publish_state();
              ESP_LOGD("TEMP_SYNC", "Synced climate platform target to %.1f°C", x);
            }
        # Trigger priority check to handle heating-only logic (current > desired = turn off)
        - script.execute: manage_heating

  # Temperature Offset (Calibration)
  - platform: template
    name: "Temperature Offset"
    id: temp_offset
    min_value: -5
    max_value: 5
    step: 0.1
    unit_of_measurement: "°C"
    icon: "mdi:plus-minus"
    restore_value: yes
    initial_value: 0
    set_action:
      then:
        - logger.log:
            format: "Temperature offset set to %.1f°C"
            args: ["x"]

  # Heating Hysteresis (deadband for stove control)
  - platform: template
    name: "Heating Hysteresis"
    id: heating_hysteresis
    min_value: 1
    max_value: 5
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:fire"
    restore_value: yes
    initial_value: 2
    set_action:
      then:
        - logger.log:
            format: "Heating hysteresis set to %.1f°C"
            args: ["x"]
        # Note: Hysteresis entity is for reference only
        # ESPHome climate platform uses its own internal hysteresis calculation

# ============================================================================
# CLIMATE ENTITY - Thermostat Control
# ============================================================================
# ESPHome climate platform provides thermostat card UI in Home Assistant and
# handles normal temperature control based on the desired_temp setpoint.
#
# The priority management system (manage_heating script in automation.yaml)
# overrides this when higher-priority modes are active (Manual Stop, Manual Run,
# or Away Mode scheduling).

climate:
  - platform: thermostat
    name: "Propane Stove Thermostat"
    id: propane_stove_thermostat
    sensor: gazebo_temp
    # Reduced times to allow faster response when setpoint changes
    min_heating_off_time: 5s
    min_heating_run_time: 30s
    min_idle_time: 5s
    
    # Heat action controls relay directly
    # Note: Priority script (manage_heating) will override if higher priorities are active
    heat_action:
      - switch.turn_on: relay
    
    # Idle action controls relay directly  
    # Note: Priority script (manage_heating) will override if higher priorities are active
    # This should trigger when current temp >= (desired temp + deadband)
    idle_action:
      - switch.turn_off: relay

# ============================================================================
# SELECT ENTITIES - Mode Selection
# ============================================================================

select:
  # Presence Mode
  - platform: template
    name: "Presence Mode"
    id: presence_mode
    options:
      - "home"
      - "away"
    initial_option: "home"
    restore_value: yes
    set_action:
      then:
        - logger.log:
            format: "Presence mode set to: %s"
            args: ["x.c_str()"]
        # Re-evaluate heating when presence changes (priority override)
        - script.execute: manage_heating

# ============================================================================
# SWITCH ENTITIES - Manual Overrides
# ============================================================================
# Note: Manual Run and Manual Stop switches are now defined in hardware.yaml
# This prevents YAML section conflicts when merging multiple includes

# ============================================================================
# TEXT SENSORS - Status Messages & Information
# ============================================================================

text_sensor:
  # WiFi Information
  - platform: wifi_info
    ip_address:
      name: "Device IP Address"
      id: device_ip
      entity_category: "diagnostic"
    ssid:
      name: "WiFi SSID"
      id: wifi_ssid
      entity_category: "diagnostic"
    mac_address:
      name: "MAC Address"
      entity_category: "diagnostic"
    bssid:
      name: "WiFi BSSID"
      entity_category: "diagnostic"

  # System Status Message
  - platform: template
    name: "System Status"
    id: system_status
    update_interval: 10s
    lambda: |-
      if (id(sensor_malfunction).state) {
        return std::string("ALARM: Sensor Malfunction");
      } else if (!id(gazebo_nextion).is_failed()) {
        return std::string("OK - Nextion Connected");
      } else {
        return std::string("OK - Display Offline");
      }

# ============================================================================
# GLOBAL VARIABLES - Internal State Tracking
# ============================================================================

globals:
  # Bad temperature read counter
  - id: bad_read_count
    type: int
    restore_value: no
    initial_value: '0'

  # Manual run state tracker (used by priority management system)
  - id: manual_run_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # Manual stop state tracker (used by priority management system)
  - id: manual_stop_active
    type: bool
    restore_value: no
    initial_value: 'false'
