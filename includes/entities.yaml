# ============================================================================
# ENTITIES - User Configuration & Status
# ============================================================================
# Number sliders, select dropdowns, binary sensors, and text sensors

# ============================================================================
# BINARY SENSORS - Status & Alarms
# ============================================================================

binary_sensor:
  # Sensor Malfunction Alarm
  - platform: template
    name: "Sensor Malfunction"
    id: sensor_malfunction
    icon: "mdi:alert-circle"
    device_class: problem
    lambda: |-
      return id(bad_read_count) > 10;

# ============================================================================
# NUMBER ENTITIES - User Configuration
# ============================================================================

number:
  # Desired Temperature Setpoint
  - platform: template
    name: "Desired Temperature"
    id: desired_temp
    min_value: 5
    max_value: 35
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:thermometer"
    restore_value: yes
    initial_value: 22
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Desired temperature set to %.1f°C"
            args: ["x"]
        # Update Nextion display if available
        - lambda: |-
            if (id(gazebo_nextion).is_failed() == false) {
              id(gazebo_nextion).send_command_printf("n1.val=%d", (int)x);
            }
        # Small delay to allow state to sync
        - delay: 50ms
        # Sync ESPHome climate platform target temperature with desired_temp
        # This ensures climate platform uses the same target as the number entity
        # The climate platform receives updates from Home Assistant API, but we also sync here
        # to ensure consistency when desired_temp is changed directly
        - lambda: |-
            // Set the climate platform's target temperature to match desired_temp
            auto* climate = id(propane_stove_thermostat);
            if (climate != nullptr) {
              climate->target_temperature = x;
              climate->publish_state();
              ESP_LOGD("TEMP_SYNC", "Synced climate platform target to %.1f°C", x);
            }
        # Trigger priority check to handle heating-only logic (current > desired = turn off)
        - script.execute: manage_heating

  # Temperature Offset (Calibration)
  - platform: template
    name: "Temperature Offset"
    id: temp_offset
    min_value: -5
    max_value: 5
    step: 0.1
    unit_of_measurement: "°C"
    icon: "mdi:plus-minus"
    restore_value: yes
    initial_value: 0
    set_action:
      then:
        - logger.log:
            format: "Temperature offset set to %.1f°C"
            args: ["x"]

  # Heating Hysteresis (deadband for stove control)
  - platform: template
    name: "Heating Hysteresis"
    id: heating_hysteresis
    min_value: 1
    max_value: 5
    step: 0.5
    unit_of_measurement: "°C"
    icon: "mdi:fire"
    restore_value: yes
    initial_value: 2
    set_action:
      then:
        - logger.log:
            format: "Heating hysteresis set to %.1f°C"
            args: ["x"]
        # Note: Hysteresis entity is for reference only
        # ESPHome climate platform uses its own internal hysteresis calculation

  # ========================================================================
  # Schedule Time Configuration Entities
  # ========================================================================

  # Home Mode Time (Hour)
  - platform: template
    name: "Home Mode Time (Hour)"
    id: home_mode_hour
    min_value: 0
    max_value: 23
    step: 1
    unit_of_measurement: "h"
    icon: "mdi:home-clock"
    restore_value: yes
    initial_value: 6
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Home mode hour set to: %.0f"
            args: ["x"]

  # Home Mode Time (Minute)
  - platform: template
    name: "Home Mode Time (Minute)"
    id: home_mode_minute
    min_value: 0
    max_value: 59
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:home-clock"
    restore_value: yes
    initial_value: 0
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Home mode minute set to: %.0f"
            args: ["x"]

  # Away Mode Time (Hour)
  - platform: template
    name: "Away Mode Time (Hour)"
    id: away_mode_hour
    min_value: 0
    max_value: 23
    step: 1
    unit_of_measurement: "h"
    icon: "mdi:clock-out"
    restore_value: yes
    initial_value: 22
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Away mode hour set to: %.0f"
            args: ["x"]

  # Away Mode Time (Minute)
  - platform: template
    name: "Away Mode Time (Minute)"
    id: away_mode_minute
    min_value: 0
    max_value: 59
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:clock-out"
    restore_value: yes
    initial_value: 0
    optimistic: true
    set_action:
      then:
        - logger.log:
            format: "Away mode minute set to: %.0f"
            args: ["x"]

# ============================================================================
# CLIMATE ENTITY - Thermostat Control
# ============================================================================
# ESPHome climate platform provides thermostat card UI in Home Assistant and
# handles normal temperature control based on the desired_temp setpoint.
#
# The priority management system (manage_heating script in automation.yaml)
# overrides this when higher-priority modes are active (Manual Stop, Manual Run,
# or Away Mode scheduling).

climate:
  - platform: thermostat
    name: "Propane Stove Thermostat"
    id: propane_stove_thermostat
    sensor: gazebo_temp
    # Reduced times to allow faster response when setpoint changes
    min_heating_off_time: 5s
    min_heating_run_time: 30s
    min_idle_time: 5s

    # Heat action triggers priority management instead of directly controlling relay
    # The manage_heating script will decide whether to turn on relay based on priorities
    heat_action:
      - logger.log: "THERMOSTAT: heat_action triggered"
      - script.execute: sync_desired_temp
      - script.execute: manage_heating

    # Idle action: when thermostat wants to stop heating, also trigger priority management
    # The manage_heating script will turn off relay if no higher priority is active
    idle_action:
      - logger.log: "THERMOSTAT: idle_action triggered"
      - script.execute: sync_desired_temp
      - script.execute: manage_heating

# ============================================================================
# SELECT ENTITIES - Mode Selection
# ============================================================================

select:
  # Presence Mode
  - platform: template
    name: "Presence Mode"
    id: presence_mode
    options:
      - "home"
      - "away"
    lambda: |-
      return id(presence_mode_state);
    set_action:
      then:
        - logger.log:
            format: "Presence mode set to: %s"
            args: ["x.c_str()"]
        - lambda: |-
            id(presence_mode_state) = x;
        # Re-evaluate heating when presence changes (priority override)
        - script.execute: manage_heating

# ============================================================================
# SWITCH ENTITIES - Manual Overrides & Schedule Control
# ============================================================================
# Note: Manual Run, Manual Stop, and Heating Schedule switches are defined
# in hardware.yaml to prevent YAML section conflicts when merging includes

# ============================================================================
# TEXT SENSORS - Status Messages & Information
# ============================================================================

text_sensor:
  # WiFi Information
  - platform: wifi_info
    ip_address:
      name: "Device IP Address"
      id: device_ip
      entity_category: "diagnostic"
    ssid:
      name: "WiFi SSID"
      id: wifi_ssid
      entity_category: "diagnostic"
    mac_address:
      name: "MAC Address"
      entity_category: "diagnostic"
    bssid:
      name: "WiFi BSSID"
      entity_category: "diagnostic"

  # System Status Message
  - platform: template
    name: "System Status"
    id: system_status
    update_interval: 10s
    lambda: |-
      if (id(sensor_malfunction).state) {
        return std::string("ALARM: Sensor Malfunction");
      } else if (!id(gazebo_nextion).is_failed()) {
        return std::string("OK - Nextion Connected");
      } else {
        return std::string("OK - Display Offline");
      }

# ============================================================================
# GLOBAL VARIABLES - Internal State Tracking
# ============================================================================

globals:
  # Bad temperature read counter
  - id: bad_read_count
    type: int
    restore_value: no
    initial_value: '0'

  # Manual run state tracker (used by priority management system)
  - id: manual_run_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # Manual stop state tracker (used by priority management system)
  - id: manual_stop_active
    type: bool
    restore_value: no
    initial_value: 'false'

  # Presence mode state tracker (Home/Away mode storage)
  # This global variable stores the presence mode state for the presence_mode select entity
  # It is used by the template select entity's lambda to read/write the current mode
  - id: presence_mode_state
    type: std::string
    restore_value: yes
    initial_value: '"home"'
