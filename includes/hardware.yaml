# ============================================================================
# HARDWARE CONFIGURATION
# ============================================================================
# GPIO pins, output drivers, relays, LEDs, one-wire bus

# ============================================================================
# ONE-WIRE BUS CONFIGURATION (GPIO4) - DS18B20 Temperature Sensor
# ============================================================================

one_wire:
  - platform: gpio
    id: ow_bus
    pin: GPIO4

# ============================================================================
# GPIO OUTPUT - Status LED (GPIO2)
# ============================================================================

output:
  - platform: gpio
    id: status_led
    pin: GPIO2
    inverted: true

light:
  - platform: binary
    name: "Status LED"
    output: status_led
    id: status_light

# ============================================================================
# RELAY STATUS (GPIO12 controlled by PID via slow_pwm in climate.yaml)
# ============================================================================
# Note: The physical relay is now controlled by the slow_pwm output in climate.yaml
# This template switch provides UI visibility and allows manual overrides

switch:
  # Relay status display - reflects slow_pwm output state
  # Note: Direct control is handled by PID; this is for monitoring/override
  - platform: template
    name: "Stove Relay"
    id: relay
    icon: "mdi:fire"
    lambda: |-
      // Read state from the heater_output_level global
      return id(heater_output_level) > 0.5;
    turn_on_action:
      then:
        - logger.log: "Relay forced ON via UI"
        - lambda: 'id(heater_output_level) = 1.0;'
        - output.set_level:
            id: heater_pwm
            level: 1.0
        - light.turn_on: status_light
    turn_off_action:
      then:
        - logger.log: "Relay forced OFF via UI"
        - lambda: 'id(heater_output_level) = 0.0;'
        - output.set_level:
            id: heater_pwm
            level: 0.0
        - light.turn_off: status_light

  # Manual Run Override (Emergency heating for 15 minutes)
  - platform: template
    name: "Manual Run"
    id: manual_run
    icon: "mdi:fire-alert"
    restore_mode: ALWAYS_OFF
    assumed_state: false
    lambda: |-
      // Switch state is controlled by manual_run_active global variable
      return id(manual_run_active);
    turn_on_action:
      then:
        - if:
            condition:
              lambda: 'return id(manual_stop_active);'
            then:
              - logger.log: "Cannot enable Manual Run: Manual Stop is active."
              # Turn the switch back off immediately in the UI to reflect that the action was rejected
              - switch.turn_off: manual_run
            else:
              - logger.log: "Manual Run enabled - 15 minute emergency heating"
              - lambda: |-
                  id(manual_run_timeout) = millis();
                  id(manual_run_active) = true;
                  ESP_LOGI("MANUAL_RUN", "Activated - 15-min timer started at %lu ms", id(manual_run_timeout));
                  // Update switch state to reflect the change
                  id(manual_run).publish_state(true);
              - script.execute: manage_heating
    turn_off_action:
      then:
        - logger.log: "Manual Run disabled"
        - lambda: |-
            id(manual_run_timeout) = 0;
            id(manual_run_active) = false;
            ESP_LOGI("MANUAL_RUN", "Deactivated by user");
            // Update switch state to reflect the change
            id(manual_run).publish_state(false);
        - script.execute: manage_heating

  # Manual Stop Override (Force heating off indefinitely)
  - platform: template
    name: "Manual Stop"
    id: manual_stop
    icon: "mdi:power-off"
    restore_mode: ALWAYS_OFF
    assumed_state: false
    lambda: |-
      return id(manual_stop_active);
    turn_on_action:
      then:
        - logger.log: "Manual Stop enabled - Heating disabled"
        - lambda: |-
            id(manual_stop_active) = true;
            // Deactivate Manual Run (mutually exclusive)
            if (id(manual_run_active)) {
              ESP_LOGI("MANUAL_STOP", "Deactivating Manual Run (mutually exclusive)");
              id(manual_run_active) = false;
              id(manual_run_timeout) = 0;
              id(manual_run).publish_state(false);
            }
            ESP_LOGI("MANUAL_STOP", "Enabled - Relay OFF indefinitely");
            id(manual_stop).publish_state(true);
        # Force heater off via PWM output
        - output.set_level:
            id: heater_pwm
            level: 0.0
        - light.turn_off: status_light
        - script.execute: update_relay_state
    turn_off_action:
      then:
        - logger.log: "Manual Stop disabled - Restoring normal control"
        - lambda: |-
            id(manual_stop_active) = false;
            ESP_LOGI("MANUAL_STOP", "Disabled - Heating control restored");
            id(manual_stop).publish_state(false);
        - script.execute: manage_heating

  # Schedule Enable Switch
  - platform: template
    name: "Schedule Enabled"
    id: schedule_enabled
    icon: "mdi:calendar-clock"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: yes
    turn_on_action:
      then:
        - logger.log: "Schedule enabled - Automatic home/away switching"
    turn_off_action:
      then:
        - logger.log: "Schedule disabled - Manual presence mode only"
