# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("cls 0x0000");
            ESP_LOGI("NEXTION_INIT", "Display cleared");

            // Update Page 0 with initial values
            id(gazebo_nextion).send_command_printf("temp.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n0.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n1.val=%d", (int)id(desired_temp).state);

            ESP_LOGI("NEXTION_INIT", "Display initialization complete");
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage heating with priority logic and hysteresis control
  # CORRECTED Priority Order: Force Off > Emergency Heat > Schedule > Thermostat Algorithm
  # *** PRIORITY 1 (HIGHEST): Manual Stop (Force Off) - disables ALL heating ***
  # *** PRIORITY 2: Manual Run (Emergency Heat) - 15 min timer, overrides schedule ***
  # *** PRIORITY 3: Presence Mode (Schedule) - controls operational vs standby modes ***
  # *** PRIORITY 4 (LOWEST): Thermostat Algorithm - maintains temperature when operational ***
  - id: manage_heating
    then:
      - lambda: |-
          float current_temp = id(gazebo_temp).state;
          // Read desired temperature from climate component
          // Falls back to desired_temp if climate component not available
          float desired = id(gazebo_thermostat).target_temperature_low;
          if (desired == 0) {
            desired = id(desired_temp).state;
          }
          float hysteresis = id(heating_hysteresis).state;
          bool schedule_standby = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);

          ESP_LOGD("PRIORITY", "ForceOff=%s, EmergencyHeat=%s, Schedule=%s",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false",
                   schedule_standby ? "standby" : "operational");

          // ========================================================================
          // Priority 1: Manual Stop (Force Off) - HIGHEST PRIORITY
          // ========================================================================
          // User has explicitly disabled all heating - MUST override all other modes
          // This is a safety feature for maintenance and emergency shutoff
          if (manual_stop) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Force Off: Relay OFF (Priority 1 - HIGHEST)");
            }
            return;
          }

          // ========================================================================
          // Priority 2: Manual Run (Emergency Heat) - 15-minute timer
          // ========================================================================
          // Emergency heating override - user manually activated emergency heat
          // Overrides schedule but respects Force Off (checked above)
          if (manual_run) {
            // Safety check: if timeout is 0, it means it was just activated or reset
            if (id(manual_run_timeout) == 0) {
              // This shouldn't happen if switch was properly activated, but handle it
              ESP_LOGW("MANUAL_RUN", "Timeout is 0 but manual_run_active is true - resetting");
              id(manual_run_timeout) = millis();
            }

            long elapsed = millis() - id(manual_run_timeout);
            long timeout_ms = 15 * 60 * 1000; // 15 minutes in milliseconds

            if (elapsed >= timeout_ms) {
              // Auto-disable after 15 minutes
              ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling");
              id(manual_run_active) = false;
              id(manual_run_timeout) = 0;
              // Continue to priority 3 (Schedule check) - don't return, let it evaluate
            } else {
              // Keep relay ON while manual run is active
              if (!id(relay).state) {
                id(relay).turn_on();
                ESP_LOGI("PRIORITY", "Emergency Heat: Relay ON (Priority 2, %ld ms remaining)", timeout_ms - elapsed);
              }
              return;
            }
          }

          // ========================================================================
          // Priority 3: Presence Mode (Schedule) - Home/Away based control
          // ========================================================================
          // Schedule-based mode controls operational vs standby states
          // "away" mode: stove is on standby (heating disabled)
          // "home" mode: allows thermostat to run
          if (schedule_standby) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Schedule: Standby mode (Priority 3) - Relay OFF");
            }
            return;
          }

          // ========================================================================
          // Priority 4: Thermostat Algorithm - LOWEST PRIORITY
          // ========================================================================
          // Normal heating control based on temperature setpoint and hysteresis
          // Only runs when higher priority modes are inactive
          float lower_threshold = desired - hysteresis/2.0;
          float upper_threshold = desired + hysteresis/2.0;

          ESP_LOGD("HEATING", "Current: %.1f°C, Desired: %.1f°C, Hysteresis: %.1f°C",
                   current_temp, desired, hysteresis);
          ESP_LOGD("HEATING", "Thresholds: Lower=%.1f, Upper=%.1f, Relay=%s",
                   lower_threshold, upper_threshold,
                   id(relay).state ? "ON" : "OFF");

          if (current_temp < lower_threshold) {
            // Temperature below setpoint - start heating
            if (!id(relay).state) {
              id(relay).turn_on();
              ESP_LOGI("HEATING", "Start heating: %.1f°C < %.1f°C (Priority 4)", current_temp, lower_threshold);
            }
          } else if (current_temp > upper_threshold) {
            // Temperature above setpoint + hysteresis - stop heating
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("HEATING", "Stop heating: %.1f°C > %.1f°C (Priority 4)", current_temp, upper_threshold);
            }
          } else {
            // Within deadband - maintain current state
            ESP_LOGD("HEATING", "In deadband: %.1f-%.1f, Relay=%s (no change)",
                     lower_threshold, upper_threshold, id(relay).state ? "ON" : "OFF");
          }

  # Update relay state (used by manual overrides to trigger priority re-evaluation)
  - id: update_relay_state
    then:
      - script.execute: manage_heating

  # Disable manual run and update switch state (used when timeout expires)
  - id: disable_manual_run
    then:
      - lambda: |-
          id(manual_run_active) = false;
          id(manual_run_timeout) = 0;
          ESP_LOGI("MANUAL_RUN", "Manual run disabled via script");
          id(manual_run).publish_state(false);
      - script.execute: manage_heating

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

interval:
  # Check Manual Run timeout every 30 seconds
  - interval: 30s
    then:
      - if:
          condition:
            - lambda: |-
                return id(manual_run_active);
          then:
            - lambda: |-
                // Safety check: if timeout is 0, skip check
                if (id(manual_run_timeout) == 0) {
                  ESP_LOGW("MANUAL_RUN", "Timeout check: timeout is 0, skipping");
                } else {
                  long elapsed = millis() - id(manual_run_timeout);
                  long timeout_ms = 15 * 60 * 1000; // 15 minutes
                  long remaining_ms = timeout_ms - elapsed;
                  long remaining_min = remaining_ms / 1000 / 60;
                  long remaining_sec = (remaining_ms / 1000) % 60;

                  if (elapsed >= timeout_ms) {
                    ESP_LOGI("MANUAL_RUN", "Timeout check: 15 minutes reached - auto-disabling");
                    id(manual_run_active) = false;
                    id(manual_run_timeout) = 0;
                  } else {
                    ESP_LOGD("MANUAL_RUN", "Timeout check: %ld:%02ld remaining", remaining_min, remaining_sec);
                  }
                }
            - script.execute: manage_heating
            - if:
                condition:
                  lambda: |-
                    return !id(manual_run_active) && id(manual_run_timeout) == 0;
                then:
                  - script.execute: disable_manual_run
