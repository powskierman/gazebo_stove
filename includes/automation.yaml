# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("cls 0x0000");
            ESP_LOGI("NEXTION_INIT", "Display cleared");

            // Update Page 0 with initial values
            id(gazebo_nextion).send_command_printf("temp.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n0.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n1.val=%d", (int)id(desired_temp).state);

            ESP_LOGI("NEXTION_INIT", "Display initialization complete");
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage heating with priority logic and hysteresis control
  # Priority: Away Mode > Manual Stop > Manual Run > Thermostat Algorithm
  - id: manage_heating
    then:
      - lambda: |-
          float current_temp = id(gazebo_temp).state;
          float desired = id(desired_temp).state;
          float hysteresis = id(heating_hysteresis).state;
          bool away_mode = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);

          ESP_LOGD("PRIORITY", "Away=%s, ManualStop=%s, ManualRun=%s",
                   away_mode ? "true" : "false",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false");

          // Priority 1: Away Mode (HIGHEST PRIORITY)
          if (away_mode) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Away mode: Relay OFF (priority 1)");
            }
            return;
          }

          // Priority 2: Manual Stop
          if (manual_stop) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Manual Stop: Relay OFF (priority 2)");
            }
            return;
          }

          // Priority 3: Manual Run (15-minute timer)
          if (manual_run) {
            long elapsed = millis() - id(manual_run_timeout);
            long timeout_ms = 15 * 60 * 1000; // 15 minutes in milliseconds

            if (elapsed >= timeout_ms) {
              // Auto-disable after 15 minutes
              ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling");
              id(manual_run_active) = false;
              // Continue to priority 4 (thermostat)
            } else {
              // Keep relay ON while manual run is active
              if (!id(relay).state) {
                id(relay).turn_on();
                ESP_LOGI("PRIORITY", "Manual Run: Relay ON (priority 3)");
              }
              return;
            }
          }

          // Priority 4: Thermostat Algorithm (LOWEST PRIORITY)
          float lower_threshold = desired - hysteresis/2.0;
          float upper_threshold = desired + hysteresis/2.0;

          ESP_LOGD("HEATING", "Current: %.1f°C, Desired: %.1f°C, Hysteresis: %.1f°C",
                   current_temp, desired, hysteresis);
          ESP_LOGD("HEATING", "Thresholds: Lower=%.1f, Upper=%.1f, Relay=%s",
                   lower_threshold, upper_threshold,
                   id(relay).state ? "ON" : "OFF");

          if (current_temp < lower_threshold) {
            // Temperature below setpoint - start heating
            if (!id(relay).state) {
              id(relay).turn_on();
              ESP_LOGI("HEATING", "Start heating: %.1f°C < %.1f°C (priority 4)", current_temp, lower_threshold);
            }
          } else if (current_temp > upper_threshold) {
            // Temperature above setpoint + hysteresis - stop heating
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("HEATING", "Stop heating: %.1f°C > %.1f°C (priority 4)", current_temp, upper_threshold);
            }
          } else {
            // Within deadband - maintain current state
            ESP_LOGD("HEATING", "In deadband: %.1f-%.1f, Relay=%s (no change)",
                     lower_threshold, upper_threshold, id(relay).state ? "ON" : "OFF");
          }

  # Update relay state (used by manual overrides to trigger priority re-evaluation)
  - id: update_relay_state
    then:
      - script.execute: manage_heating

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

interval:
  # Check Manual Run timeout every 30 seconds
  - interval: 30s
    then:
      - if:
          condition:
            - lambda: |-
                return id(manual_run_active);
          then:
            - lambda: |-
                long elapsed = millis() - id(manual_run_timeout);
                long timeout_ms = 15 * 60 * 1000; // 15 minutes
                long remaining_ms = timeout_ms - elapsed;
                long remaining_min = remaining_ms / 1000 / 60;
                long remaining_sec = (remaining_ms / 1000) % 60;

                if (elapsed >= timeout_ms) {
                  ESP_LOGI("MANUAL_RUN", "Timeout check: 15 minutes reached - auto-disabling");
                  id(manual_run_active) = false;
                } else {
                  ESP_LOGD("MANUAL_RUN", "Timeout check: %ld:%02ld remaining", remaining_min, remaining_sec);
                }
            - script.execute: manage_heating
