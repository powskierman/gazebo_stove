# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("cls 0x0000");
            ESP_LOGI("NEXTION_INIT", "Display cleared");

            // Update Page 0 with initial values
            id(gazebo_nextion).send_command_printf("temp.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n0.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n1.val=%d", (int)id(desired_temp).state);

            ESP_LOGI("NEXTION_INIT", "Display initialization complete");
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage Heating
  # This script is the single entry point for all heating state changes.
  # It applies a priority-based logic to determine the final state of the relay.
  #
  # Priority System:
  # 1. Manual Stop (Force Off): Highest priority, forces the relay OFF.
  # 2. Manual Run (Emergency Heat): Forces the relay ON for a fixed duration.
  # 3. Presence Mode (Away): Forces the relay OFF.
  # 4. Thermostat Control: The climate entity controls the relay based on temperature.
  - id: manage_heating
    then:
      - lambda: |-
          bool away_mode = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);

          ESP_LOGI("PRIORITY", "=== APPLY_PRIORITY_OVERRIDES CALLED ===");
          ESP_LOGI("PRIORITY", "ManualStop=%s, ManualRun=%s, Away=%s",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false",
                   away_mode ? "true" : "false");

          // Priority 1: Force Off (Manual Stop) - HIGHEST PRIORITY
          if (manual_stop) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Priority 1: Force Off - Relay OFF");
            }
            return;
          }

          // Priority 2: Emergency Heat (Manual Run)
          if (manual_run) {
            if (!id(relay).state) {
              id(relay).turn_on();
              ESP_LOGI("PRIORITY", "Priority 2: Emergency Heat - Relay ON");
            }
            return;
          }

          // Priority 3: Away Mode - Override to OFF
          if (away_mode) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Priority 3: Away Mode - Relay OFF");
            }
            return;
          }

          // Priority 4: Climate control (default)
          // If no overrides are active, the relay state is determined by the
          // climate entity's heat_action and idle_action. No further action needed.
          ESP_LOGI("PRIORITY", "Priority 4: No overrides - Climate platform has control");

  # Manual Run Timer - Implements 15-minute auto-off using delay (replaces polling)
  # This script is started when Manual Run is activated and automatically
  # disables it after 15 minutes without needing continuous polling checks.
  - id: manual_run_timer
    then:
      - delay: 15min
      - lambda: |-
          ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling Manual Run");
          id(manual_run_active) = false;
          id(manual_run).publish_state(false);
      - script.execute: manage_heating


# ============================================================================
# TIME-BASED AUTOMATIONS - Schedule Control (Priority 3)
# ============================================================================
# These automations run at specific times each day to automatically switch
# between Home Mode and Away Mode based on user-configured schedule times.
# The schedule can be enabled/disabled via the schedule_enabled switch.
#
# Note: ESPHome uses interval-based time triggers that check every minute.
# For precise triggering at dynamic times, we use a 1-minute interval to
# check if the current time matches the scheduled time.

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

# ============================================================================

interval:
  - interval: 1min
    then:
      - if:
          condition:
            - lambda: |-
                return id(schedule_enabled).state && id(sntp_time)->now().is_valid();
          then:
            - lambda: |-
                auto time = id(sntp_time)->now();
                int current_minute_of_day = time.hour * 60 + time.minute;

                int home_minute_of_day = (int)id(home_mode_hour).state * 60 + (int)id(home_mode_minute).state;
                int away_minute_of_day = (int)id(away_mode_hour).state * 60 + (int)id(away_mode_minute).state;

                std::string scheduled_mode = "away"; // Default to away
                if (home_minute_of_day < away_minute_of_day) { // Normal day schedule
                    if (current_minute_of_day >= home_minute_of_day && current_minute_of_day < away_minute_of_day) {
                        scheduled_mode = "home";
                    }
                } else { // Overnight schedule
                    if (current_minute_of_day >= home_minute_of_day || current_minute_of_day < away_minute_of_day) {
                        scheduled_mode = "home";
                    }
                }

                if (id(presence_mode).state != scheduled_mode) {
                    if (!id(presence_mode_manual)) {
                        id(presence_mode).publish_state(scheduled_mode);
                    }
                } else {
                    if (id(presence_mode_manual)) {
                        id(presence_mode_manual) = false;
                    }
                }

# ============================================================================
# EVENT-DRIVEN PRIORITY SYSTEM
# ============================================================================
# The priority system is now fully event-driven instead of polling.
# It triggers only when relevant state changes occur:
#
# Trigger Points:
# 1. Manual Stop (Priority 1): Triggers in hardware.yaml turn_on/off_action
# 2. Manual Run (Priority 2): Triggers in hardware.yaml turn_on/off_action
# 3. Presence Mode (Priority 3): Triggers in entities.yaml set_action
# 4. Desired Temp (Priority 4): Triggers in entities.yaml set_action
#
# Each of these already calls manage_heating in their action handlers.
# No additional automation needed - all triggers are event-based!

# ============================================================================
# NOTE: Thermostat Control Architecture
# ============================================================================
# The ESPHome climate platform (thermostat component) handles normal temperature
# control with symmetric hysteresis via heat_deadband and heat_overrun settings.
#
# The manage_heating script applies priority-based overrides on top of the climate
# platform to implement:
#   - Priority 1: Manual Stop (Force Off) blocks all heating
#   - Priority 2: Manual Run (Emergency Heat) for 15 minutes
#   - Priority 3: Away Mode scheduling forces relay off
#   - Priority 4: Climate platform controls heating normally
#
# This multi-tier priority system cannot be replaced by ESPHome's thermostat
# component alone, as it requires application-specific safety logic.
