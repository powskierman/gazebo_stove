# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Read Nextion Slider0 value and update thermostat
  # This script is called when touch is released on Page 3
  - id: read_nextion_slider
    then:
      - delay: 100ms  # Small delay for Nextion to process
      - lambda: |-
          // Send a command to request Slider0 value
          // The response will come via UART and be logged
          // For now, we use the touch event component_id to estimate the value
          // Full bi-directional communication requires Nextion to send data proactively
          
          // Get the stored slider value from our global
          int slider_val = (int)id(nextion_slider_value);
          if (slider_val >= 0 && slider_val <= 100) {
            // Convert slider value (0-100) to temperature (15-30°C)
            float desired_temp = 15.0 + ((float)slider_val / 100.0) * 15.0;
            ESP_LOGI("NEXTION_SLIDER", "Slider value: %d -> Temperature: %.1f°C", slider_val, desired_temp);
            
            // Update thermostat target temperature
            auto call = id(gazebo_thermostat).make_call();
            call.set_target_temperature(desired_temp);
            call.perform();
            
            // Update n0 display immediately (desired temp on left)
            id(gazebo_nextion).send_command_printf("three.n0.val=%d", (int)desired_temp);
          }

  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - delay: 30s  # Wait for ESP32 and Nextion to settle
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("bkcmd=3"); // Enable return data
            id(gazebo_nextion).send_command("cls 0x0000");
            id(gazebo_nextion).send_command("page 0"); // Force Page 0 (ID 0)
            ESP_LOGI("NEXTION_INIT", "Display cleared and switched to Page 0");

            // ============================================================
            // Page 0: Update with initial values
            // ============================================================
            // Temperature
            id(gazebo_nextion).send_command_printf("zero.temp.val=%d", (int)id(gazebo_temp).state);
            
            // Humidity/Precip
            if (!isnan(id(gazebo_humidity).state)) {
              id(gazebo_nextion).send_command_printf("zero.precip.val=%d", (int)id(gazebo_humidity).state);
            }

            // ============================================================
            // Page 3: Initialize temperature controls
            // ============================================================
            float target = id(gazebo_thermostat).target_temperature;
            // n0: desired temperature (left side)
            id(gazebo_nextion).send_command_printf("three.n0.val=%d", (int)target);
            // n1: actual temperature (right side)
            id(gazebo_nextion).send_command_printf("three.n1.val=%d", (int)id(gazebo_temp).state);
            // Slider0: map 15-30°C to 0-100
            int slider_val = (int)(((target - 15.0) / 15.0) * 100.0);
            if (slider_val < 0) slider_val = 0;
            if (slider_val > 100) slider_val = 100;
            id(gazebo_nextion).send_command_printf("three.Slider0.val=%d", slider_val);

            // Mark Nextion as ready for other components to send
            id(nextion_ready) = true;
            ESP_LOGI("NEXTION_INIT", "Display initialization complete (target=%.1f, slider=%d)", target, slider_val);
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage heating with priority logic for PID Controller
  # PRIORITY ORDER: Force Off > Emergency Heat > Schedule > PID Thermostat
  # *** PRIORITY 1 (HIGHEST): Manual Stop (Force Off) - disables ALL heating ***
  # *** PRIORITY 2: Manual Run (Emergency Heat) - 15 min timer, forces heat ON ***
  # *** PRIORITY 3: Presence Mode (Schedule) - Away mode disables heating ***
  # *** PRIORITY 4 (LOWEST): PID Controller - automatic temperature control ***
  - id: manage_heating
    then:
      # Check priorities and set action flags
      - lambda: |-
          bool schedule_standby = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);
          float pwm_output = id(heater_output_level);

          ESP_LOGI("PRIORITY", "Inputs: ForceOff=%s, EmergencyHeat=%s, ScheduleStandby=%s, PID_Output=%.1f%%",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false",
                   schedule_standby ? "YES" : "NO",
                   pwm_output * 100.0);

          // Determine action based on priority
          // Store decision in heating_action global: 0=PID, 1=ForceOff, 2=EmergencyHeat, 3=Standby
          
          // Priority 1: Manual Stop (Force Off) - HIGHEST PRIORITY
          if (manual_stop) {
            id(heating_status).publish_state("Forced Off");
            id(heating_action) = 1;
            ESP_LOGI("PRIORITY", "Force Off active (Priority 1 - HIGHEST)");
            return;
          }

          // Priority 2: Manual Run (Emergency Heat) - 15-minute timer
          if (manual_run) {
            id(heating_status).publish_state("Emergency Heat");
            
            if (id(manual_run_timeout) == 0) {
              ESP_LOGW("MANUAL_RUN", "Timeout is 0 but manual_run_active is true - resetting");
              id(manual_run_timeout) = millis();
            }

            long elapsed = millis() - id(manual_run_timeout);
            long timeout_ms = 15 * 60 * 1000;

            if (elapsed >= timeout_ms) {
              ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling");
              id(manual_run_active) = false;
              id(manual_run_timeout) = 0;
              // Will check other priorities on next call
              id(heating_action) = 0;
            } else {
              id(heating_action) = 2;
              ESP_LOGI("PRIORITY", "Emergency Heat: %ld min remaining (Priority 2)", 
                       (timeout_ms - elapsed) / 60000);
              return;
            }
          }

          // Priority 3: Presence Mode (Schedule) - Home/Away based control
          if (schedule_standby) {
            id(heating_status).publish_state("Schedule Standby");
            id(heating_action) = 3;
            ESP_LOGI("PRIORITY", "Schedule: Away mode - Standby (Priority 3)");
            return;
          }

          // Priority 4: PID Controller - Let PID manage heating automatically
          id(heating_action) = 0;
          
          // Update status based on PID output
          if (pwm_output > 0.5) {
            id(heating_status).publish_state("Heating");
          } else if (pwm_output > 0) {
            id(heating_status).publish_state("Low Heat");
          } else {
            id(heating_status).publish_state("Idle");
          }
          
          ESP_LOGI("PID", "Current: %.1f°C, Target: %.1f°C, Output: %.0f%%",
                   id(gazebo_temp).state,
                   id(gazebo_thermostat).target_temperature,
                   pwm_output * 100.0);
      
      # Execute action based on heating_action value
      - if:
          condition:
            lambda: 'return id(heating_action) == 1;'  # Force Off
          then:
            - output.set_level:
                id: heater_pwm
                level: 0.0
            - lambda: 'id(heater_output_level) = 0.0;'
      - if:
          condition:
            lambda: 'return id(heating_action) == 2;'  # Emergency Heat
          then:
            - output.set_level:
                id: heater_pwm
                level: 1.0
            - lambda: 'id(heater_output_level) = 1.0;'
      - if:
          condition:
            lambda: 'return id(heating_action) == 3;'  # Standby
          then:
            - climate.control:
                id: gazebo_thermostat
                mode: "OFF"
      - if:
          condition:
            lambda: 'return id(heating_action) == 0 && id(gazebo_thermostat).mode == climate::CLIMATE_MODE_OFF;'
          then:
            - climate.control:
                id: gazebo_thermostat
                mode: "HEAT"
            - logger.log: "PID: Restoring HEAT mode (Priority 4)"

  # Update relay state (used by manual overrides to trigger priority re-evaluation)
  - id: update_relay_state
    then:
      - script.execute: manage_heating

  # Disable manual run and update switch state (used when timeout expires)
  - id: disable_manual_run
    then:
      - lambda: |-
          id(manual_run_active) = false;
          id(manual_run_timeout) = 0;
          ESP_LOGI("MANUAL_RUN", "Manual run disabled via script");
          id(manual_run).publish_state(false);
      - script.execute: manage_heating

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

interval:
  # Check Manual Run timeout every 30 seconds
  - interval: 30s
    then:
      - if:
          condition:
            - lambda: |-
                return id(manual_run_active);
          then:
            - lambda: |-
                // Safety check: if timeout is 0, skip check
                if (id(manual_run_timeout) == 0) {
                  ESP_LOGW("MANUAL_RUN", "Timeout check: timeout is 0, skipping");
                } else {
                  long elapsed = millis() - id(manual_run_timeout);
                  long timeout_ms = 15 * 60 * 1000; // 15 minutes
                  long remaining_ms = timeout_ms - elapsed;
                  long remaining_min = remaining_ms / 1000 / 60;
                  long remaining_sec = (remaining_ms / 1000) % 60;

                  if (elapsed >= timeout_ms) {
                    ESP_LOGI("MANUAL_RUN", "Timeout check: 15 minutes reached - auto-disabling");
                    id(manual_run_active) = false;
                    id(manual_run_timeout) = 0;
                  } else {
                    ESP_LOGD("MANUAL_RUN", "Timeout check: %ld:%02ld remaining", remaining_min, remaining_sec);
                  }
                }
            - script.execute: manage_heating
            - if:
                condition:
                  lambda: |-
                    return !id(manual_run_active) && id(manual_run_timeout) == 0;
                then:
                  - script.execute: disable_manual_run

  # Periodic Display Refresh (every 5s)
  - interval: 5s
    then:
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
             // Refresh Temperature
             if (!isnan(id(gazebo_temp).state)) {
               int t = (int)id(gazebo_temp).state;
               id(gazebo_nextion).send_command_printf("zero.temp.val=%d", t);
               id(gazebo_nextion).send_command_printf("temp.val=%d", t);
             }
             // Refresh Humidity
             if (!isnan(id(gazebo_humidity).state)) {
               int h = (int)id(gazebo_humidity).state;
               id(gazebo_nextion).send_command_printf("zero.precip.val=%d", h);
               id(gazebo_nextion).send_command_printf("precip.val=%d", h);
             }
          }

  # Periodic heating evaluation every 30 seconds
  # This ensures manage_heating runs even when temperature is stable
  # (delta filter on temperature sensor prevents on_value from firing)
  - interval: 30s
    then:
      - script.execute: manage_heating

  # Schedule-based presence mode automation
  # Checks every minute if we should be in home or away mode based on schedule
  - interval: 60s
    then:
      - if:
          condition:
            # Only run if schedule is enabled
            - switch.is_on: schedule_enabled
          then:
            - lambda: |-
                // Get current time from SNTP time source
                auto time = id(sntp_time).now();
                if (!time.is_valid()) {
                  ESP_LOGW("SCHEDULE", "Time not synced yet, skipping schedule check");
                  return;
                }

                // Get schedule times from datetime entities
                auto home_time = id(schedule_1_home).state_as_esptime();
                auto away_time = id(schedule_2_away).state_as_esptime();

                // Current time in minutes since midnight
                int current_minutes = time.hour * 60 + time.minute;
                int home_minutes = home_time.hour * 60 + home_time.minute;
                int away_minutes = away_time.hour * 60 + away_time.minute;

                // CHANGED: Log at INFO level so user can see what's happening
                ESP_LOGI("SCHEDULE", "Check: Current=%02d:%02d (%d), Home=%02d:%02d (%d), Away=%02d:%02d (%d)",
                         time.hour, time.minute, current_minutes,
                         home_time.hour, home_time.minute, home_minutes,
                         away_time.hour, away_time.minute, away_minutes);

                // Handle edge case: equality
                if (home_minutes == away_minutes) {
                   ESP_LOGW("SCHEDULE", "Home and Away times are identical - staying in current mode");
                   return;
                }

                // Determine if we should be in home or away mode
                bool should_be_home = false;
                if (home_minutes < away_minutes) {
                  // Normal case: home 06:00 -> away 22:00 (within same day)
                  should_be_home = (current_minutes >= home_minutes && current_minutes < away_minutes);
                } else {
                  // Wraparound case: home 22:00 -> away 08:00 (crosses midnight)
                  should_be_home = (current_minutes >= home_minutes || current_minutes < away_minutes);
                }

                // Update presence mode if needed (or if Climate Mode is out of sync)
                std::string desired_mode = should_be_home ? "home" : "away";
                std::string current_mode = id(presence_mode).state;
                
                bool climate_mismatch = false;
                if (desired_mode == "away") {
                   // If Away, Climate should be OFF
                   if (id(gazebo_thermostat).mode != climate::CLIMATE_MODE_OFF) {
                     climate_mismatch = true;
                   }
                } else {
                   // If Home, Climate should NOT be OFF (should be HEAT)
                   if (id(gazebo_thermostat).mode == climate::CLIMATE_MODE_OFF) {
                     climate_mismatch = true;
                   }
                }

                if (current_mode != desired_mode || climate_mismatch) {
                  ESP_LOGI("SCHEDULE", "Updating presence mode: %s -> %s (Climate Mismatch: %s)", 
                           current_mode.c_str(), desired_mode.c_str(), climate_mismatch ? "YES" : "NO");
                  auto call = id(presence_mode).make_call();
                  call.set_option(desired_mode);
                  call.perform();
                } else {
                  // CHANGED: Log at INFO level to confirm it's working but no change needed
                  ESP_LOGI("SCHEDULE", "Presence mode correct: %s (No change)", current_mode.c_str());
                }
          else:
            - logger.log:
                level: WARN
                tag: "SCHEDULE"
                format: "Schedule check skipped: Schedule is DISABLED"
