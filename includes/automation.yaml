# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("bkcmd=3"); // Enable return data
            id(gazebo_nextion).send_command("cls 0x0000");
            id(gazebo_nextion).send_command("page 0"); // Force Page 0 (ID 0)
            ESP_LOGI("NEXTION_INIT", "Display cleared and switched to Page 0");

            // Update Page 0 with initial values
            // Temperature
            id(gazebo_nextion).send_command_printf("zero.temp.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("temp.val=%d", (int)id(gazebo_temp).state);
            
            // Humidity/Precip
            if (!isnan(id(gazebo_humidity).state)) {
              id(gazebo_nextion).send_command_printf("zero.precip.val=%d", (int)id(gazebo_humidity).state);
              id(gazebo_nextion).send_command_printf("precip.val=%d", (int)id(gazebo_humidity).state);
            }

            ESP_LOGI("NEXTION_INIT", "Display initialization complete");
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage heating with priority logic and hysteresis control
  # CORRECTED Priority Order: Force Off > Emergency Heat > Schedule > Thermostat Algorithm
  # *** PRIORITY 1 (HIGHEST): Manual Stop (Force Off) - disables ALL heating ***
  # *** PRIORITY 2: Manual Run (Emergency Heat) - 15 min timer, overrides schedule ***
  # *** PRIORITY 3: Presence Mode (Schedule) - controls operational vs standby modes ***
  # *** PRIORITY 4 (LOWEST): Thermostat Algorithm - maintains temperature when operational ***
  - id: manage_heating
    then:
      - lambda: |-
          float current_temp = id(gazebo_temp).state;
          float desired = id(desired_temp).state;
          float hysteresis = id(heating_hysteresis).state;
          bool schedule_standby = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);

          ESP_LOGD("PRIORITY", "ForceOff=%s, EmergencyHeat=%s, Schedule=%s",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false",
                   schedule_standby ? "standby" : "operational");

          // ========================================================================
          // Priority 1: Manual Stop (Force Off) - HIGHEST PRIORITY
          // ========================================================================
          if (manual_stop) {
            id(heating_status).publish_state("Forced Off");
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Force Off: Relay OFF (Priority 1 - HIGHEST)");
            }
            return;
          }

          // ========================================================================
          // Priority 2: Manual Run (Emergency Heat) - 15-minute timer
          // ========================================================================
          if (manual_run) {
            id(heating_status).publish_state("Emergency Heat");
            if (id(manual_run_timeout) == 0) {
              ESP_LOGW("MANUAL_RUN", "Timeout is 0 but manual_run_active is true - resetting");
              id(manual_run_timeout) = millis();
            }

            long elapsed = millis() - id(manual_run_timeout);
            long timeout_ms = 15 * 60 * 1000;

            if (elapsed >= timeout_ms) {
              ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling");
              id(manual_run_active) = false;
              id(manual_run_timeout) = 0;
            } else {
              if (!id(relay).state) {
                id(relay).turn_on();
                ESP_LOGI("PRIORITY", "Emergency Heat: Relay ON (Priority 2, %ld ms remaining)", timeout_ms - elapsed);
              }
              return;
            }
          }

          // ========================================================================
          // Priority 3: Presence Mode (Schedule) - Home/Away based control
          // ========================================================================
          if (schedule_standby) {
            id(heating_status).publish_state("Schedule Standby");
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Schedule: Standby mode (Priority 3) - Relay OFF");
            }
            return;
          }

          // ========================================================================
          // Priority 4: Thermostat Algorithm - LOWEST PRIORITY
          // ========================================================================
          float lower_threshold = desired - hysteresis;
          float upper_threshold = desired + hysteresis;

          ESP_LOGD("HEATING", "Current: %.1f°C, Desired: %.1f°C, Hysteresis: %.1f°C",
                   current_temp, desired, hysteresis);
          ESP_LOGD("HEATING", "Asymmetric Thresholds: Lower=%.1f, Upper=%.1f, Relay=%s",
                   lower_threshold, upper_threshold,
                   id(relay).state ? "ON" : "OFF");

          if (current_temp <= lower_threshold) {
            id(heating_status).publish_state("Heating");
            if (!id(relay).state) {
              id(relay).turn_on();
              ESP_LOGI("HEATING", "Start heating: %.1f°C <= %.1f°C (Priority 4)", current_temp, lower_threshold);
            }
          } else if (current_temp >= upper_threshold) {
            id(heating_status).publish_state("Idle");
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("HEATING", "Stop heating: %.1f°C >= %.1f°C (Priority 4)", current_temp, upper_threshold);
            }
          } else {
            // If we are in the deadband, the state is either "Heating" or "Idle" depending on the relay state
            if (id(relay).state) {
              id(heating_status).publish_state("Heating");
            } else {
              id(heating_status).publish_state("Idle");
            }
            ESP_LOGD("HEATING", "In deadband: (%.1f, %.1f), Relay=%s (no change)",
                     lower_threshold, upper_threshold, id(relay).state ? "ON" : "OFF");
          }

  # Update relay state (used by manual overrides to trigger priority re-evaluation)
  - id: update_relay_state
    then:
      - script.execute: manage_heating

  # Disable manual run and update switch state (used when timeout expires)
  - id: disable_manual_run
    then:
      - lambda: |-
          id(manual_run_active) = false;
          id(manual_run_timeout) = 0;
          ESP_LOGI("MANUAL_RUN", "Manual run disabled via script");
          id(manual_run).publish_state(false);
      - script.execute: manage_heating

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

interval:
  # Check Manual Run timeout every 30 seconds
  - interval: 30s
    then:
      - if:
          condition:
            - lambda: |-
                return id(manual_run_active);
          then:
            - lambda: |-
                // Safety check: if timeout is 0, skip check
                if (id(manual_run_timeout) == 0) {
                  ESP_LOGW("MANUAL_RUN", "Timeout check: timeout is 0, skipping");
                } else {
                  long elapsed = millis() - id(manual_run_timeout);
                  long timeout_ms = 15 * 60 * 1000; // 15 minutes
                  long remaining_ms = timeout_ms - elapsed;
                  long remaining_min = remaining_ms / 1000 / 60;
                  long remaining_sec = (remaining_ms / 1000) % 60;

                  if (elapsed >= timeout_ms) {
                    ESP_LOGI("MANUAL_RUN", "Timeout check: 15 minutes reached - auto-disabling");
                    id(manual_run_active) = false;
                    id(manual_run_timeout) = 0;
                  } else {
                    ESP_LOGD("MANUAL_RUN", "Timeout check: %ld:%02ld remaining", remaining_min, remaining_sec);
                  }
                }
            - script.execute: manage_heating
            - if:
                condition:
                  lambda: |-
                    return !id(manual_run_active) && id(manual_run_timeout) == 0;
                then:
                  - script.execute: disable_manual_run

  # Periodic Display Refresh (every 5s)
  - interval: 5s
    then:
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
             // Refresh Temperature
             if (!isnan(id(gazebo_temp).state)) {
               int t = (int)id(gazebo_temp).state;
               id(gazebo_nextion).send_command_printf("zero.temp.val=%d", t);
               id(gazebo_nextion).send_command_printf("temp.val=%d", t);
             }
             // Refresh Humidity
             if (!isnan(id(gazebo_humidity).state)) {
               int h = (int)id(gazebo_humidity).state;
               id(gazebo_nextion).send_command_printf("zero.precip.val=%d", h);
               id(gazebo_nextion).send_command_printf("precip.val=%d", h);
             }
          }

  # Periodic heating evaluation every 30 seconds
  # This ensures manage_heating runs even when temperature is stable
  # (delta filter on temperature sensor prevents on_value from firing)
  - interval: 30s
    then:
      - script.execute: manage_heating

  # Schedule-based presence mode automation
  # Checks every minute if we should be in home or away mode based on schedule
  - interval: 60s
    then:
      - if:
          condition:
            # Only run if schedule is enabled
            - switch.is_on: schedule_enabled
          then:
            - lambda: |-
                // Get current time from SNTP time source
                auto time = id(sntp_time).now();
                if (!time.is_valid()) {
                  ESP_LOGW("SCHEDULE", "Time not synced yet, skipping schedule check");
                  return;
                }

                // Get schedule times from datetime entities
                auto home_time = id(schedule_1_home).state_as_esptime();
                auto away_time = id(schedule_2_away).state_as_esptime();

                // Current time in minutes since midnight
                int current_minutes = time.hour * 60 + time.minute;
                int home_minutes = home_time.hour * 60 + home_time.minute;
                int away_minutes = away_time.hour * 60 + away_time.minute;

                ESP_LOGD("SCHEDULE", "Current: %02d:%02d (%d min), Home: %02d:%02d (%d min), Away: %02d:%02d (%d min)",
                         time.hour, time.minute, current_minutes,
                         home_time.hour, home_time.minute, home_minutes,
                         away_time.hour, away_time.minute, away_minutes);

                // Determine if we should be in home or away mode
                bool should_be_home = false;
                if (home_minutes < away_minutes) {
                  // Normal case: home 06:00 -> away 22:00 (within same day)
                  should_be_home = (current_minutes >= home_minutes && current_minutes < away_minutes);
                } else {
                  // Wraparound case: home 22:00 -> away 08:00 (crosses midnight)
                  should_be_home = (current_minutes >= home_minutes || current_minutes < away_minutes);
                }

                // Update presence mode if needed
                std::string desired_mode = should_be_home ? "home" : "away";
                std::string current_mode = id(presence_mode).state;

                if (current_mode != desired_mode) {
                  ESP_LOGI("SCHEDULE", "Updating presence mode: %s -> %s", current_mode.c_str(), desired_mode.c_str());
                  auto call = id(presence_mode).make_call();
                  call.set_option(desired_mode);
                  call.perform();
                } else {
                  ESP_LOGD("SCHEDULE", "Presence mode already correct: %s", current_mode.c_str());
                }
