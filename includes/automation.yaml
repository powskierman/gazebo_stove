# ============================================================================
# AUTOMATION & CONTROL LOGIC
# ============================================================================
# Scripts for heating control, display initialization, and system management

script:
  # Initialize Nextion display on boot
  - id: init_nextion
    then:
      - logger.log: "Initializing Nextion display..."
      - lambda: |-
          if (id(gazebo_nextion).is_failed() == false) {
            id(gazebo_nextion).send_command("cls 0x0000");
            ESP_LOGI("NEXTION_INIT", "Display cleared");

            // Update Page 0 with initial values
            id(gazebo_nextion).send_command_printf("temp.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n0.val=%d", (int)id(gazebo_temp).state);
            id(gazebo_nextion).send_command_printf("n1.val=%d", (int)id(desired_temp).state);

            ESP_LOGI("NEXTION_INIT", "Display initialization complete");
          } else {
            ESP_LOGE("NEXTION_INIT", "Nextion display failed - cannot initialize");
          }

  # Manage heating with priority logic (overrides thermostat)
  # Priority: Force Off (Manual Stop) > Emergency Heat (Manual Run) > Schedule (Away Mode) > Thermostat
  # This script only handles priority overrides - normal temperature control is done by the thermostat
  - id: manage_heating
    then:
      - lambda: |-
          bool away_mode = (id(presence_mode).state == "away");
          bool manual_stop = id(manual_stop_active);
          bool manual_run = id(manual_run_active);

          ESP_LOGD("PRIORITY", "Away=%s, ManualStop=%s, ManualRun=%s",
                   away_mode ? "true" : "false",
                   manual_stop ? "true" : "false",
                   manual_run ? "true" : "false");

          // Priority 1: Force Off (Manual Stop) - HIGHEST PRIORITY
          if (manual_stop) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Force Off: Relay OFF (priority 1)");
            }
            return;
          }

          // Priority 2: Emergency Heat (Manual Run)
          // The manual_run_timer script handles the 15-minute auto-disable
          // This priority just needs to keep relay ON while manual_run_active is true
          if (manual_run) {
            if (!id(relay).state) {
              id(relay).turn_on();
              ESP_LOGI("PRIORITY", "Emergency Heat: Relay ON (priority 2)");
            }
            return;
          }

          // Priority 3: Schedule (Away Mode)
          if (away_mode) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Schedule: Standby mode - Relay OFF (priority 3)");
            }
            return;
          }

          // Priority 4: Thermostat control
          // ESPHome climate platform handles thermostat control, but we need to handle
          // the case where desired temp < current temp (heating-only system should turn off)
          float current_temp = id(gazebo_temp).state;
          float desired = id(desired_temp).state;
          
          // For heating-only system: if current temp > desired temp, turn off immediately
          // This handles the case where user lowers setpoint below current temperature
          // The climate platform might not handle this immediately due to min_heating_run_time
          if (current_temp > desired) {
            if (id(relay).state) {
              id(relay).turn_off();
              ESP_LOGI("PRIORITY", "Desired temp (%.1f째C) < Current temp (%.1f째C) - Relay OFF (heating-only)",
                       desired, current_temp);
            }
            // Return here - don't let climate platform turn it back on while current > desired
            return;
          }
          
          // When current temp < desired temp, let climate platform control heating
          // The climate platform will evaluate on sensor updates and turn relay on/off
          // We don't interfere here - just let it work
          ESP_LOGD("PRIORITY", "Current (%.1f째C) < Desired (%.1f째C) - Climate platform controls (no interference)",
                   current_temp, desired);
          // Note: Don't return here - let script finish so climate platform can control relay

  # Update relay state (used by manual overrides to trigger priority re-evaluation)
  - id: update_relay_state
    then:
      - script.execute: manage_heating

  # Manual Run Timer - Implements 15-minute auto-off using delay (replaces polling)
  # This script is started when Manual Run is activated and automatically
  # disables it after 15 minutes without needing continuous polling checks.
  - id: manual_run_timer
    then:
      - delay: 15min
      - lambda: |-
          ESP_LOGI("MANUAL_RUN", "15-minute timeout reached - auto-disabling Manual Run");
          id(manual_run_active) = false;
          id(manual_run).publish_state(false);
      - script.execute: manage_heating


# ============================================================================
# TIME-BASED AUTOMATIONS - Schedule Control (Priority 3)
# ============================================================================
# These automations run at specific times each day to automatically switch
# between Home Mode and Away Mode based on user-configured schedule times.
# The schedule can be enabled/disabled via the schedule_enabled switch.
#
# Note: ESPHome uses interval-based time triggers that check every minute.
# For precise triggering at dynamic times, we use a 1-minute interval to
# check if the current time matches the scheduled time.

# ============================================================================
# INTERVAL AUTOMATIONS - Periodic Tasks
# ============================================================================

interval:
  # Check schedule every minute to trigger home/away mode changes
  # This compares the current time to the configured schedule times
  - interval: 1min
    then:
      - if:
          condition:
            - lambda: |-
                if (!id(schedule_enabled).state) return false;  // Skip if schedule disabled

                auto time = id(sntp_time);
                if (time->now().is_valid() == false) return false;  // Skip if time not synced

                int current_hour = time->now().hour;
                int current_minute = time->now().minute;
                int home_hour = (int)id(home_mode_hour).state;
                int home_minute = (int)id(home_mode_minute).state;

                // Check if current time >= home mode time (trigger when reaching scheduled hour:minute)
                // Prevents missing schedule if changed after it already passed today
                if ((current_hour > home_hour) ||
                    (current_hour == home_hour && current_minute >= home_minute)) {
                  if (id(presence_mode).state != "home") {
                    return true;  // Time to switch to home mode
                  }
                }

                return false;
          then:
            - logger.log: "Schedule: Switching to Home Mode"
            - lambda: |-
                id(presence_mode).publish_state("home");

  # Check for away mode schedule separately (every minute)
  - interval: 1min
    then:
      - if:
          condition:
            - lambda: |-
                if (!id(schedule_enabled).state) return false;  // Skip if schedule disabled

                auto time = id(sntp_time);
                if (time->now().is_valid() == false) return false;  // Skip if time not synced

                int current_hour = time->now().hour;
                int current_minute = time->now().minute;
                int away_hour = (int)id(away_mode_hour).state;
                int away_minute = (int)id(away_mode_minute).state;

                // Check if current time >= away mode time (trigger when reaching scheduled hour:minute)
                // Prevents missing schedule if changed after it already passed today
                if ((current_hour > away_hour) ||
                    (current_hour == away_hour && current_minute >= away_minute)) {
                  if (id(presence_mode).state != "away") {
                    return true;  // Time to switch to away mode
                  }
                }

                return false;
          then:
            - logger.log: "Schedule: Switching to Away Mode"
            - lambda: |-
                id(presence_mode).publish_state("away");

# ============================================================================
# EVENT-DRIVEN PRIORITY SYSTEM
# ============================================================================
# The priority system is now fully event-driven instead of polling.
# It triggers only when relevant state changes occur:
#
# Trigger Points:
# 1. Manual Stop (Priority 1): Triggers in hardware.yaml turn_on/off_action
# 2. Manual Run (Priority 2): Triggers in hardware.yaml turn_on/off_action
# 3. Presence Mode (Priority 3): Triggers in entities.yaml set_action
# 4. Desired Temp (Priority 4): Triggers in entities.yaml set_action
#
# Each of these already calls manage_heating in their action handlers.
# No additional automation needed - all triggers are event-based!

# ============================================================================
# NOTE: Thermostat Control Architecture
# ============================================================================
# The ESPHome climate platform (thermostat component) handles normal temperature
# control with symmetric hysteresis via heat_deadband and heat_overrun settings.
#
# The manage_heating script applies priority-based overrides on top of the climate
# platform to implement:
#   - Priority 1: Manual Stop (Force Off) blocks all heating
#   - Priority 2: Manual Run (Emergency Heat) for 15 minutes
#   - Priority 3: Away Mode scheduling forces relay off
#   - Priority 4: Climate platform controls heating normally
#
# This multi-tier priority system cannot be replaced by ESPHome's thermostat
# component alone, as it requires application-specific safety logic.
